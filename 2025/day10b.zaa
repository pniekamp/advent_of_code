import std.stdio;
import std.algorithm;
import std.flat_hash_map;
import std.scan;

struct machine
{
  std::string diagram;
  std::string schematics;
  std::string requirements;

  std::vector<std::vector<usize>> buttons;

  machine() = default;
  machine(machine &&) = default;
  ~machine() = default;
}

fn gauss_elimination(std::vector<std::vector<int>> mut &matrix) -> std::vector<usize>
{
  let N = matrix.len;
  let M = matrix[0].len - 1;

  var i = usize(0);
  var j = usize(0);
  var prev_pivot = 1;
  var independents = std::vector<usize>();

  for (; j < N && i < M; )
  {
    var pivot = j;

    for (var jj = j + 1; jj < N; ++jj)
    {
      if (matrix[jj][i] != 0)
        pivot = jj;
    }

    if (matrix[pivot][i] == 0)
    {
      independents.push_back(i++);
      continue;
    }

    std::swap(&mut matrix[j], &mut matrix[pivot]);

    for (var jj = 0; jj < N; ++jj)
    {
      if (jj != j)
      {
        var factor = matrix[jj][i];

        for (var ii = 0; ii < M + 1; ++ii)
        {
          matrix[jj][ii] = (matrix[jj][ii] * matrix[j][i] - factor * matrix[j][ii]) / prev_pivot;
        }
      }
    }

    prev_pivot = matrix[j][i];

    ++i; ++j;
  }

  for (; i < M; )
  {
    independents.push_back(i++);
  }

  return independents;
}

fn gauss_jordan_elimination(std::vector<std::vector<float>> mut &matrix) -> std::vector<usize>
{
  let N = matrix.len;
  let M = matrix[0].len - 1;

  var i = 0;
  var j = 0;
  var independents = std::vector<usize>();

  for (; j < N && i < M; )
  {
    var pivot = j;

    for (var jj = j + 1; jj < N; ++jj)
    {
      if (std::abs(matrix[jj][i]) > std::abs(matrix[pivot][i]))
        pivot = jj;
    }

    if (std::fcmp(matrix[pivot][i], 0.0))
    {
      independents.push_back(i++);
      continue;
    }

    std::swap(&mut matrix[j], &mut matrix[pivot]);

    for (var ii = i + 1; ii < M + 1; ++ii)
    {
      matrix[j][ii] /= matrix[j][i];
    }

    for (var jj = 0; jj < N; ++jj)
    {
      if (jj != j && matrix[jj][i] != 0.0)
      {
        for (var ii = i + 1; ii < M + 1; ++ii)
        {
          matrix[jj][ii] -= matrix[jj][i] * matrix[j][ii];
        }

        matrix[jj][i] = 0.0;
      }
    }

    matrix[j][i] = 1.0;

    ++i; ++j;
  }

  for (; i < M; )
  {
    independents.push_back(i++);
  }

  return independents;
}

fn check(std::vector<std::vector<int>> &matrix, std::vector<usize> &variables, std::vector<int> &state) -> std::optional<int>
{
  let N = matrix.len;
  let M = matrix[0].len - 1;

  var solution = std::vector<int>::with_capacity(M);

  for (var k = 0; k < N; ++k)
  {
    var pivot = matrix[k].find_if(|v| v != 0);

    if (pivot == matrix[k].end)
      continue;

    var value = matrix[k].back;

    for (var [i, j] : variables.enumerate)
      value -= matrix[k][j] * state[i];

    if (value % *pivot != 0 || value / *pivot < 0)
      return None;

    solution.push_back(value / *pivot);
  }

//  for (var [i, j] : variables.enumerate)
//  {
//    solution.insert(j, state[i]);
//  }

//  std::print(solution);
//  for (var j = 0; j < N; ++j)
//  {
//    var value = 0;
//    for (var i = 0; i < M; ++i)
//      value += matrix[j][i] * solution[i];
//    std::print(matrix[j], " ", value);
//  }
//  std::print("---");

  return state.sum + solution.sum;
}

fn main -> int
{
  try
  {
    var machines = std::vector<machine>();

    var fin = std::file::open("day10.txt");

    for (var line : std::buffered_reader(&mut fin).lines)
    {
      var machine = machine();

      if (std::sscanf(line, "[{}]{}{{{}}}", &mut machine.diagram, &mut machine.schematics, &mut machine.requirements).error)
        std::panic("error scaning machine from input '", line, "'");

      for (var &schematic : machine.schematics.words)
      {
        var lights = schematic.strip_prefix("(").strip_suffix(")").split(",");

        machine.buttons.push_back(std::vector::from(lights.transform(|str| { var n = usize(); std::atoi(str.begin, str.end, &mut n); return n; })));
      }

      machines.push_back(machine);
    }

    var presses = 0;

    for (var &machine : machines)
    {
      var min = 99999;
      var matrix = std::vector<std::vector<int>>();

      for (var &joltage : machine.requirements.split(","))
      {
        var value = int(0);
        std::atoi(joltage.begin, joltage.end, &mut value);

        matrix.push_back().resize(machine.buttons.len + 1);
        matrix.back.back = value;
      }

      for (var i = 0; i < machine.buttons.len; ++i)
      {
        for (var j : machine.buttons[i])
          matrix[j][i] = 1;
      }

      var variables = gauss_elimination(&mut matrix);

      var states = std::vector<std::vector<int>>();

      states.push_back(std::vector<int>::with_size(variables.len));

      for (; !states.empty; )
      {
        for (var state : states.take(states.begin, states.end))
        {
          if (var sum = check(matrix, variables, state); sum && sum < min)
            min = sum?!;

          if (state.sum >= min)
            continue;

          for (var i = 0; i < state.len; ++i)
          {
            var newstate = state;

            newstate[i] += 1;

            states.push_back(newstate);
          }
        }

        states.erase(std::unique(&mut states.sort!), states.end);
      }

      presses += min;
    }

    std::print("part2: fewest button presses ", presses);
  }
  catch(std::error e)
  {
    std::panic(e);
  }

  return 0;
}
